- 冒泡排序

```js
function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 交换
      }
    }
  }
  return arr;
}
```

- 插入排序

```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
}
```

- 快速排序
```js
function quickSort(arr,left,right){
  if(left>=right) return;

  let pivot=arr[right];
  let i=left;
  for(let j=left;j<right;j++){
    if(arr[j]<=pivot){
      [arr[i],arr[j]]=[arr[j],arr[i]];
      i++;
    }
  }
  [arr[i],arr[right]]=[arr[right],arr[i]];

  quickSort(arr,left,i-1);
  quickSort(arr,i+1,right);
}
var sortArray=function(nums){
  quickSort(nums,0,nums.length-1);
  return nums;
}
```

- 归并排序
```js
function mergeSort(arr,left,right){
  if(arr.length<=1) return arr;
  let mid=left+right>>>1;
  let leftArr=mergeSort(arr,left,mid);
  let rightArr=mergeSort(arr,mid+1,right);
  return merge(leftArr,rightArr);
}
function merge(arr1,arr2){
  let res=[];
  let i=0,j=0;
  while(i<arr1.length&&j<arr2.length){
    if(arr1[i]<=arr2[j]){
      res.push(arr1[i]);
      i++;
    }else{
      res.push(arr2[j]);
      j++;
    }
  }
  if(arr1.length) res.push(...arr1);
  if(arr2.length) res.push(...arr2);
  return res;
  // return res.concat(arr1.slice(i),arr2.slice(j));
}
```

- debounce
```js
function debounce(fn,delay){
  let timer=null;
  return function(...args){
    if(timer) clearTimeout(timer);
    timer=setTimeout(()=>{
      fn.apply(this,args);
    },delay);
  };
}

// use
window.addEventListener('resize',debounce(()=>{
  console.log('resize')
},500));
```

- throttle
```js
function throttle(fn,interval){
  let last=0;
  return function(...args){
    const now=Date.now();
    if(now-last>=interval){
      last=now;
      fn.apply(this,args);
    }
  }

  
} 
//use 
window.addEventListener('scroll',throttle(()=>{
    console.log('throttle');
  },500));
```

- promise.all
```js
function myPromiseAll(iterable){
  return new Promise((resolve,reject)=>{
    const promises=Array.from(iterable);
    const res=[];
    let completed=0;

    if(promises.length===0){
      return resolve([]);
    }

    promises.forEach((p,i)=>{
      Promise.resolve(p).then(
        val=>{
          res[i]=val;
          completed++;
          if(completed===promises.length){
            resolve(res);
          }          
        },
        err=>reject(err);
      )
    })
  })
}
```
- vue resize 生命周期
```vue
<script setup>
  import{ref,onMounted,onbeforeUnmount} from 'vue';

  const width=ref(window.innerWidth);
  const height=ref(window.innerHeight);

  function handleResize(){
    width.value=window.innerWidth;
    height.value=window.innerHeight;
  }
  onMounted(()=>{
    window.addEventListener('resize',handleResize);
  })
  onbeforeUnmount(()=>{
    window.removeEventListener('resize',handleResize);
  })
</script>

<template>
  <div>
    <p>当前窗口宽度：{{width}}</p>
    <p>当前窗口高度：{{height}}</p>
  </div>
</template>
```

- 树状地区模糊匹配
```js
const regions = [
  {
    name: "江苏省",
    children: [
      { name: "南京市", children: [{ name: "鼓楼区" }, { name: "玄武区" }] },
      { name: "苏州市", children: [{ name: "吴中区" }, { name: "园区" }] }
    ]
  },
  {
    name: "浙江省",
    children: [
      { name: "杭州市", children: [{ name: "西湖区" }, { name: "滨江区" }] }
    ]
  }
];

function fuzzyMatch(regions,keyword){
  const dfs=(nodes)=>{
    const res=[];
    for(let node of nodes){
      let matched=node.name.includes(keyword);
      let children=node.children?dfs(node.children):[];
      if(matched||children.length){
        res.push({...node,children:children});
      }
    }
    return res;
  };
  return dfs(regions);
}
// use it
console.log(fuzzyMatch(regions,'江'));
```

- shallowCopy
```js
function shallowCopy(obj){
  if(Array.isArray(obj)) return [...obj];
  if(obj&&typeof obj==='object') return {...obj};
  return obj;
}
//example
const a={x:1,y:{z:1}};
const b=shallowCopy(a);
b.y.z=2;
console.log(a.y.z);//2
```

- deepCopy
```js
function deepCopy(obj,map=new WeakMap()){
  if(obj===null||typeof obj!=='object') return obj;
  if(map.has(obj)) return map.get(obj);
  if(obj instanceof Date) return new Date(obj);
  if(obj instanceof RegExp) return new RegExp(obj);

  const copy=Array.isArray(obj)?[]:{};
  map.set(obj,copy);

  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      copy[key]=deepCopy(obj[key],map);
    }
  }
  return copy;
}
```

- function curry
```js
function curry(fn){
  const args=[];
  function curried(...newArgs){
    if(newArgs.length===0){
      return fn(...args);
    }else{
      return curried;
    }
  }
  return curried;
}
```

- eventemitter
```js
class eventEmitter{
  constructor(){
    this.events={};
  }

  on(event,listener){
    // 如果事件不存在，创建空数组
    if(!this.events[event]){
      this.events[event]=[];
    }
    // 将监听器添加到事件数组中
    this.events[event].push(listener);
  }
  // 注册一次性事件监听器，执行一次之后就自动移除
  once(event,listener){
    const wrapper=(...args)=>{
      listener(...args); // 执行原始监听器
      this.off(event,wrapper); // 执行后移除监听器
    }
    this.on(event,wrapper);// 注册包装后的监听器
  }
  // 移除事件监听器
  off(event,listener){
    if(!this.events[event]) return; // 如果事件不存在 直接返回
    // 过滤掉要移除的监听器
    this.events[event]=this.events[event].filter(l=>l!==listener);
  }
  // 触发事件
  emit(event,...args){
    if(!this.events[event]) return; // 如果事件不存在 直接返回
    // 遍历执行所有的监听器，并传递参数
    this.events[event].forEach(listener=>listener(...args));
  }
}

// use it
// 创建事件发射器实例
const emitter = new EventEmitter();

// 注册普通事件
emitter.on('message', (text) => {
  console.log(`收到消息: ${text}`);
});

// 注册一次性事件
emitter.once('first-time', () => {
  console.log('这个只会执行一次!');
});

// 触发事件
emitter.emit('message', '你好世界!'); // 输出: 收到消息: 你好世界!
emitter.emit('first-time'); // 输出: 这个只会执行一次!
emitter.emit('first-time'); // 不会有输出，因为是一次性事件

// 移除事件
const handler = (data) => console.log('处理数据:', data);
emitter.on('data', handler);
emitter.off('data', handler);
emitter.emit('data', '一些数据'); // 不会有输出，因为监听器已被移除
```


- JSONP

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function (data) {
    success(data)
  }
  document.body.appendChild(script)
}
jsonp('https://xxx', 'callback', function (value) {
  console.log(value)
})
```

- proxy 通过 webpack 给本地服务器作为请求的代理
  vue.config.js

```js
module.exports = {
  devServer: {
    host: '127.0.0.1',
    port: 8080,
    open: true, // vue项目启动时自动打开浏览器
    proxy: {
      '/api': {
        // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
        target: 'http://xxx.xxx.xx.xx:8080', //目标地址，一般是指后台服务器地址
        changeOrigin: true, //是否跨域
        pathRewrite: {
          // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
          '^/api': ''
        }
      }
    }
  }
}
```

- 防抖

```js
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeOUT(() => {
      fn.apply(this.args)
    }, delay)
  }
}

window.addEventListener(
  'resize',
  debounce(() => {
    console.lof('resize')
  }, 500)
)
```

- 节流

```js
function throttle(fn, interval) {
  let last = 0
  return function (...args) {
    const now = Date.now()
    if (now - last >= interval) {
      last = now
      fn.apply(this, args)
    }
  }
}

window.addEventListener(
  'scroll',
  throttle(() => {
    console.log('throttle')
  }, 200)
)
```

- promise.all

```js
Promise._all = function (promises) {
  let ans = []
  return new Promise((resolve, reject) => {
    promises.forEach(item => {
      val => {
        ans.push(val)
        if (ans.length === promises.length) {
          resolve(ans)
        }
      },
        err => {
          reject(err)
        }
    })
  })
}
```
