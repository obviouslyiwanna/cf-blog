## 排序算法

-  冒泡排序

```js
function bubbleSort(arr) {
   let n = arr.length;
   for (let i = 0; i < n - 1; i++) {
      let swapped = false;
      for (let j = 0; j < i; j++) {
         if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            swapped = true;
         }
      }
      if (!swapped) break;
   }
}
```

-  插入排序

```js
function insertionSort(arr) {
   for (let i = 1; i < arr.length; i++) {
      let key = arr[i];
      let j = i - 1;
      while (j >= 0 && arr[j] > key) {
         arr[j + 1] = arr[j];
         j--;
      }
      arr[j + 1] = key;
   }
   return arr;
}
```

-  快速排序

```js
function quickSort(arr, left, right) {
   if (left >= right) return;

   let pivot = arr[right];
   let i = left;
   for (let j = left; j < right; j++) {
      if (arr[j] <= pivot) {
         [arr[i], arr[j]] = [arr[j], arr[i]];
         i++;
      }
   }
   [arr[i], arr[right]] = [arr[right], arr[i]];

   quickSort(arr, left, i - 1);
   quickSort(arr, i + 1, right);
}
var sortArray = function (nums) {
   quickSort(nums, 0, nums.length - 1);
   return nums;
};
```

-  归并排序

```js
function mergeSort(arr, left, right) {
   if (arr.length <= 1) return arr[left];
   let mid = (left + right) >>> 1;
   let leftArr = mergeSort(arr, left, mid);
   let rightArr = mergeSort(arr, mid + 1, right);
   return merge(leftArr, rightArr);
}
function merge(arr1, arr2) {
   let res = [];
   let i = 0,
      j = 0;
   while (i < arr1.length && j < arr2.length) {
      if (arra[i] < arr2[j]) {
         res.push(arr1[i++]);
      } else {
         res.push(arr2[j++]);
      }
   }
   res.push(...arr1.slice(i), ...arr2.slice(j));
   return res;
}
```

-  堆

```js
class MinHeap {
   constructor() {
      this.heap = [];
   }

   size() {
      return this.heap.length;
   }

   peek() {
      return this.heap[0];
   }

   push(val) {
      this.heap.push(val);
      this._siftUp(this.heap.length - 1);
   }

   pop() {
      const top = this.heap[0];
      const last = this.heap.pop();
      if (this.heap.length > 0) {
         this.heap[0] = last;
         this._siftDown(0);
      }
      return top;
   }

   _siftUp(index) {
      let parent = (index - 1) >>> 1;
      while (index >= 0 && this.heap[index] < this.heap[parent]) {
         [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]];
         index = parent;
         parent = (index - 1) >>> 1;
      }
   }

   _siftDown(index) {
      const n = this.heap.length;
      while (true) {
         let smallest = index;
         let left = index * 2 + 1,
            right = index * 2 + 2;
         if (left < n && this.heap[left] < this.heap[smallest]) {
            smallest = left;
         }
         if (right < n && this.heap[right] < this.heap[smallest]) {
            smallest = right;
         }
         if (smallest !== index) {
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
         }
         if (smallest === index) {
            break;
         }
      }
   }
}

function heapSort(arr) {
   const heap = new MinHeap();
   for (const num of arr) {
      heap.push(num);
   }
   const res = [];
   while (heap.size() > 0) {
      res.push(heap.pop());
   }
   return res;
}
```

-  洗牌算法

```js
function shuffle(arr) {
   for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
   }
   return arr;
}
```

## 防抖和节流

防抖（debounce）
● 触发事件后，延迟一段时间再执行函数，如果在这段时间内又触发了，则重新计时。
● 应用场景：输入框搜索（用户停止输入后才发请求）、窗口 resize。

-  debounce

```js
function debounce(fn, delay) {
   let timer = null;
   return function (...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
         fn.apply(this, args);
      }, delay);
   };
}

window.addEventListener(
   'resize',
   debounce(() => {
      console.log('resize');
   }, 500)
);
```

节流（throttle）
● 触发事件后，在 一定间隔内只执行一次函数，不管触发多少次。
● 应用场景：滚动事件（scroll）、鼠标移动（mousemove）。

-  throttle

```js
function throttle(fn, interval) {
   let last = 0;
   return function (...args) {
      const now = Date.now();
      if (now - last >= interval) {
         last = now;
         fn.apply(this, args);
      }
   };
}

window.addEventListener(
   'scroll',
   throttle(() => {
      console.log('scroll');
   }, 200)
);
```

## 浅拷贝和深拷贝

-  shallowCopy

```js
function shallowCopy(obj) {
   if (Array.isArray(obj)) return [...obj];
   if (obj && typeof obj === 'object') return { ...obj };
   return obj;
}
//example
const a = { x: 1, y: { z: 1 } };
const b = shallowCopy(a);
b.y.z = 2;
console.log(a.y.z); //2
```

-  deepCopy

```js
function deepCopy(obj, map = new WeakMap()) {
   if (obj === null || typeof obj !== 'object') return obj;
   if (map.has(obj)) return map.get(obj);
   if (obj instanceof Date) return new Date(obj);
   if (obj instanceof RegExp) return new RegExp(pbj);

   const copy = Array.isArray(obj) ? [] : {};
   map.set(obj, copy);

   for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
         copy[key] = deepCopy(obj[key], map);
      }
   }
   return copy;
}
```

## 函数柯里化

```js
function curry(fn) {
   return function curried(...args) {
      if (args.length >= fn.length) {
         return fn.apply(this, args);
      }
      return function (...nextArgs) {
         return curried.apply(this, args.concat(nextArgs));
      };
   };
}
```

## promise

-  promise.all

```js
function promiseAll(iterable) {
   return new Promise((resolve, reject) => {
      const promises = Array.from(iterable);
      const results = [];
      let count = 0;

      if (promises.length === 0) return resolve([]);

      promises.forEach((p, i) => {
         Promise.resolve(p).then(
            value => {
               results[i] = value; // 保证结果顺序一致
               count++;
               if (count === promises.length) resolve(results);
            },
            reject // 等价于 err => reject(err)
         );
      });
   });
}
```

-  vue resize 生命周期

```vue
<script setup>
import { ref, onMounted, onbeforeUnmount } from 'vue';

const width = ref(window.innerWidth);
const height = ref(window.innerHeight);

function handleResize() {
   width.value = window.innerWidth;
   height.value = window.innerHeight;
}
onMounted(() => {
   window.addEventListener('resize', handleResize);
});
onbeforeUnmount(() => {
   window.removeEventListener('resize', handleResize);
});
</script>

<template>
   <div>
      <p>当前窗口宽度：{{ width }}</p>
      <p>当前窗口高度：{{ height }}</p>
   </div>
</template>
```

-  树状地区模糊匹配

```js
const regions = [
   {
      name: '江苏省',
      children: [
         { name: '南京市', children: [{ name: '鼓楼区' }, { name: '玄武区' }] },
         { name: '苏州市', children: [{ name: '吴中区' }, { name: '园区' }] },
      ],
   },
   {
      name: '浙江省',
      children: [{ name: '杭州市', children: [{ name: '西湖区' }, { name: '滨江区' }] }],
   },
];

function fuzzyMatch(regions, keyword) {
   const dfs = nodes => {
      const res = [];
      for (let node of nodes) {
         let matched = node.name.includes(keyword);
         let children = node.children ? dfs(node.children) : [];
         if (matched || children.length) {
            res.push({ ...node, children: children });
         }
      }
      return res;
   };
   return dfs(regions);
}
// use it
console.log(fuzzyMatch(regions, '江'));
```

-  function curry

```js
function curry(fn) {
   const args = [];
   function curried(...newArgs) {
      if (newArgs.length === 0) {
         return fn(...args);
      } else {
         return curried;
      }
   }
   return curried;
}
```

-  eventemitter

```js
class eventEmitter {
   constructor() {
      this.events = {};
   }

   on(event, listener) {
      // 如果事件不存在，创建空数组
      if (!this.events[event]) {
         this.events[event] = [];
      }
      // 将监听器添加到事件数组中
      this.events[event].push(listener);
   }
   // 注册一次性事件监听器，执行一次之后就自动移除
   once(event, listener) {
      const wrapper = (...args) => {
         listener(...args); // 执行原始监听器
         this.off(event, wrapper); // 执行后移除监听器
      };
      this.on(event, wrapper); // 注册包装后的监听器
   }
   // 移除事件监听器
   off(event, listener) {
      if (!this.events[event]) return; // 如果事件不存在 直接返回
      // 过滤掉要移除的监听器
      this.events[event] = this.events[event].filter(l => l !== listener);
   }
   // 触发事件
   emit(event, ...args) {
      if (!this.events[event]) return; // 如果事件不存在 直接返回
      // 遍历执行所有的监听器，并传递参数
      this.events[event].forEach(listener => listener(...args));
   }
}

// use it
// 创建事件发射器实例
const emitter = new EventEmitter();

// 注册普通事件
emitter.on('message', text => {
   console.log(`收到消息: ${text}`);
});

// 注册一次性事件
emitter.once('first-time', () => {
   console.log('这个只会执行一次!');
});

// 触发事件
emitter.emit('message', '你好世界!'); // 输出: 收到消息: 你好世界!
emitter.emit('first-time'); // 输出: 这个只会执行一次!
emitter.emit('first-time'); // 不会有输出，因为是一次性事件

// 移除事件
const handler = data => console.log('处理数据:', data);
emitter.on('data', handler);
emitter.off('data', handler);
emitter.emit('data', '一些数据'); // 不会有输出，因为监听器已被移除
```

-  JSONP

```js
function jsonp(url, jsonpCallback, success) {
   let script = document.createElement('script');
   script.src = url;
   script.async = true;
   script.type = 'text/javascript';
   window[jsonpCallback] = function (data) {
      success(data);
   };
   document.body.appendChild(script);
}
jsonp('https://xxx', 'callback', function (value) {
   console.log(value);
});
```

-  proxy 通过 webpack 给本地服务器作为请求的代理
   vue.config.js

```js
module.exports = {
   devServer: {
      host: '127.0.0.1',
      port: 8080,
      open: true, // vue项目启动时自动打开浏览器
      proxy: {
         '/api': {
            // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
            target: 'http://xxx.xxx.xx.xx:8080', //目标地址，一般是指后台服务器地址
            changeOrigin: true, //是否跨域
            pathRewrite: {
               // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
               '^/api': '',
            },
         },
      },
   },
};
```

-  防抖

```js
function debounce(fn, delay) {
   let timer = null;
   return function (...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeOUT(() => {
         fn.apply(this.args);
      }, delay);
   };
}

window.addEventListener(
   'resize',
   debounce(() => {
      console.lof('resize');
   }, 500)
);
```

-  节流

```js
function throttle(fn, interval) {
   let last = 0;
   return function (...args) {
      const now = Date.now();
      if (now - last >= interval) {
         last = now;
         fn.apply(this, args);
      }
   };
}

window.addEventListener(
   'scroll',
   throttle(() => {
      console.log('throttle');
   }, 200)
);
```

-  promise.all

```js
Promise._all = function (promises) {
   let ans = [];
   return new Promise((resolve, reject) => {
      promises.forEach(item => {
         val => {
            ans.push(val);
            if (ans.length === promises.length) {
               resolve(ans);
            }
         },
            err => {
               reject(err);
            };
      });
   });
};
```
