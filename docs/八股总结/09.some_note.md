## **专项面试题清单**

### **模块 1：前端基础与原理**

> **目标**：保证基础扎实，应对高频原理题和追问

1. **HTML/CSS**

    * ***盒模型***
        在浏览器中，盒模型（Box Model）描述了一个元素的大小由哪些部分组成。

        1. 标准盒模型（content-box，W3C 盒模型）

        width / height 只包含 内容区域（content） 的宽高。

        元素的总宽度 = content + padding + border + margin。
    
        2. 怪异盒模型（border-box，IE 盒模型）

        width / height 包含 内容 + 内边距（padding） + 边框（border），不包含 margin。

        内容区域大小 = width - padding - border。

        3. 切换方式

        通过 box-sizing 属性控制：

        box-sizing: content-box → 标准盒模型（默认值）

        box-sizing: border-box → 怪异盒模型

        4. 使用场景

        标准盒模型更符合传统的 CSS 规范，计算内容大小时直观。

        怪异盒模型在做自适应布局时更方便，比如固定宽度的卡片，内部 padding 不会撑破布局。

        5. 总结

        两种盒模型的差异在于 width/height 的计算范围，了解差异有助于避免布局错位和尺寸计算错误。
    - *延伸问题*：
        1. 如何在全局设置所有元素为怪异盒模型？为什么这么做？
        可以通过 CSS 重置（reset.css）或全局样式（global.css）设置所有元素为怪异盒模型。
        例如：
        ```css
        * {
            box-sizing: border-box;
        }
        ```
        这么做的好处是避免计算 padding/border 时撑破布局，减少尺寸计算复杂度。
        2. 如何判断某个元素当前的盒模型类型？
        可以通过 getComputedStyle 方法获取元素的当前计算样式，其中 box-sizing 就是其中之一。
        ```js
        getComputedStyle(element).boxSizing
        ```
        3. margin 塌陷（Margin Collapse）与盒模型的关系？

        margin 塌陷是垂直方向相邻块元素外边距的合并，与盒模型定义不同，但布局时可能一起影响结果。
    * ***BFC 原理及应用场景***
        1. 定义
        BFC（Block Formatting Context）是页面中的一个独立渲染区域，在该区域中，元素的布局不受外部元素影响，并且也不会影响外部的布局。

        2. 特性

        内部的元素会在垂直方向一个接一个排列。

        BFC 区域与外部元素的 margin 不会发生折叠。

        BFC 区域不会与浮动元素重叠，会将浮动元素“包裹”起来。

        计算 BFC 高度时会包含浮动元素的高度。

        3. 常见触发方式（任一满足即可）

        float 的值不为 none

        position 为 absolute 或 fixed

        display 为 inline-block、table-cell、table-caption、flex、inline-flex、grid、inline-grid

        overflow 的值不为 visible（如 hidden、auto、scroll）

        4. 应用场景

        清除浮动：父元素触发 BFC，可以自动包裹内部浮动子元素，避免高度塌陷。

        防止 margin 合并：相邻块元素如果在不同 BFC 中，margin 不会合并。

        布局隔离：让某块布局不受外部影响，比如防止文字环绕浮动图片。

        5. 总结
        BFC 是 CSS 中重要的布局概念，理解它的触发条件和特性可以解决常见的浮动、塌陷、布局错位等问题。
    - *延伸问题*：
        1. BFC 与 IFC（行内格式化上下文）的区别？

        BFC 内元素是块级布局，IFC 内元素是行内布局（文字、行内块等）。

        2. 清除浮动还有哪些方法？BFC 相比之下的优缺点？

        其他方法如 clear: both、伪元素清除法（.clearfix::after）。

        BFC 不会额外增加 DOM，也不依赖额外 CSS 选择器，较为简洁。

        3. overflow: hidden 触发 BFC 的副作用？

        可能裁剪超出容器的内容。

    * ***浮动（float）与清除浮动***
        1. 定义与原理

        float 最初设计用于让文字环绕图片（比如图文排版），会让元素脱离标准文档流（不占据原来的块级位置），但仍然保留在所在容器的文本流中。

        浮动元素会向左或向右移动，直到碰到父容器边界或另一个浮动元素。

        2. 特性

        浮动元素不再占据标准流位置，但会影响其后的行内内容（文字、inline 元素会围绕它排布）。

        块级元素如果没触发 BFC 或没清除浮动，不会自动包裹浮动元素的高度 → 产生高度塌陷。
        3. 清除浮动的方法

        CSS clear 属性

        ```css
        .clearfix {
        clear: both; /* 清除左右浮动的影响 */
        }
        ```
        伪元素法（推荐）

        ```css
        .clearfix::after {
        content: "";
        display: block;
        clear: both;
        }
        ```
        触发 BFC（如 overflow: hidden）

        父元素触发 BFC 后会自动包含浮动子元素的高度。

        4. 现代布局趋势

        现在布局多用 Flexbox 或 Grid 代替 float，因为它们更灵活、可控。

        float 主要用于简单图文混排或兼容旧项目。
    
   * ***display 的常见取值及区别***
        1. block（块级元素）

        独占一行，默认宽度撑满父容器，高度由内容决定。

        可以设置 width/height、margin/padding。

        常见如 `<div>、<p>、<section>`。

        2. inline（行内元素）

        与其他行内元素在同一行内显示，宽高由内容撑开，不能直接设置宽高。

        padding/margin 在水平方向有效，垂直方向可能不生效。

        常见如` <span>、<a>、<em>`。

        3. inline-block（行内块）

        像 inline 一样不独占一行，但可以像 block 一样设置宽高、padding、margin。

        常用于水平排列的可设置尺寸的元素（如按钮组）。

        4. flex（弹性布局）

        父元素设 display: flex，子元素变成 flex items，支持主轴/交叉轴对齐、空间分配、伸缩。

        适合一维布局（水平或垂直）。

        5. grid（网格布局）

        父元素设 display: grid，子元素按网格行列布局，可精确控制行高列宽。

        适合二维布局。

        6. table / table-cell / table-row

        模拟表格布局，可按表格单元格规则排列内容，适合某些需要等高列的场景。

        7. none

        元素不显示且不占据空间（与 visibility: hidden 区别在于不占位）。
    - *延伸问题*：
        1. inline 和 inline-block 的区别？

        inline-block 可设置宽高，inline 不行。

        2. flex 和 grid 的适用场景区别？

        flex 适合一维（主轴优先），grid 适合二维（行列同时控制）。

        3. 如何让两个 div 在一行内等高排列？

        flex（align-items: stretch）或 grid（行高自动拉伸）。

    * ***重排（Reflow）与重绘（Repaint）的触发条件与优化手段***
        1. 定义

        重排（Reflow / Layout）：当元素的几何尺寸（宽、高、位置）发生变化，浏览器需要重新计算布局并重新渲染。

        重绘（Repaint）：当元素的外观样式（颜色、背景、阴影等）发生变化，但几何尺寸不变时，只需重新绘制，不重新计算布局。

        2. 触发条件
        重排常见触发：

            添加/删除 DOM 元素

            元素尺寸、位置变化（width、height、margin、padding、top/left 等）

            浏览器窗口大小变化（触发响应式布局）

            获取布局信息（offsetTop、offsetHeight、getComputedStyle() 等）

        重绘常见触发：

            修改背景色、文字颜色

            改变 visibility（但 display:none 会触发重排）

            添加/修改 box-shadow

        关系：

            重排一定会引发重绘，但重绘不一定会引发重排。

        3. 性能优化手段

        减少重排次数

            样式集中修改：批量更改样式或使用 class 切换，而不是多次修改单个样式属性。

            使用文档片段（DocumentFragment）批量插入 DOM。

            元素离线处理：对要频繁操作的元素使用 display:none（触发一次重排，隐藏后修改不再触发），修改完成再显示。

            避免频繁读取布局信息（会强制触发回流），可先缓存结果。

        减少重绘开销

            尽量合并视觉修改，比如动画中用 transform 和 opacity（GPU 加速）替代直接修改位置和背景。

            避免复杂 CSS 选择器导致重绘范围大。

        4. 总结

        重排影响更大，应优先优化，避免频繁修改布局属性。

        动画尽量用 `transform` 和 `opacity`，它们不会触发重排（通常只触发合成层变化）。
    - *延伸问题*：
        1. visibility: hidden 和 display: none 对性能的影响？

        display:none 触发重排，visibility:hidden 只触发重绘。

        2. 为什么频繁读取 offsetHeight 会影响性能？

        会强制浏览器刷新渲染队列（flush），立刻计算最新布局，阻塞渲染线程。

        3. 如何优化高频动画的性能？

        用 transform: translateZ(0) 开启 GPU 加速，避免 layout 阶段参与。

   * ***position: float/absolute/fixed/sticky 区别***
        1. float（浮动）

        让元素脱离标准文档流，但仍处于文本流中，会影响周围的 inline 内容（如文字环绕）。

        按 left 或 right 浮动，直到碰到父容器的边界或另一个浮动元素。

        常用于文字环绕图片或老式布局，现在多用 flex/grid 替代。

        2. absolute（绝对定位）

        完全脱离文档流，不占据原位置，也不影响其他元素布局。

        参考对象：离它最近的 position 不为 static 的祖先元素；如果找不到，就相对 初始包含块（通常是 html/body）。

        常用于精确摆放元素（弹窗、按钮等）。

        3. relative（相对定位）

        不脱离文档流，仍占据原本位置，但可以通过 top/left/right/bottom 相对自己原位置偏移。

        偏移后，原本的位置仍保留（周围元素不受影响）。

        常用于微调元素位置，或者给子元素 absolute 提供参考定位点。

        4. sticky（粘性定位）

        结合了 relative 和 fixed 的特性：在达到设定的偏移阈值前是相对定位，达到阈值后会固定在视口位置。

        参考对象：最近的可滚动祖先元素的滚动区域。

        常用于表头固定、导航条吸顶等效果。
        \| 定位方式 | 脱离文档流 | 参考对象 | 常用场景 |

        > \| 定位方式 | 脱离文档流  | 参考对象             | 常用场景 |
        > \| float    | 是（部分） | 父容器宽度            | 图文混排、旧布局 |
        > \| absolute | 是        | 最近的非 static 祖先 | 精确定位 |
        > \| relative | 否        | 自己原位置          | 微调位置、定位参考点 |
        > \| sticky   | 否（初期） | 最近的可滚动祖先      | 吸顶、固定表头 |
    - *延伸问题*：
        1. absolute 的参考对象具体是怎么算的？

        从当前元素向上找第一个 position 不为 static 的祖先元素。

        2. sticky 为什么有时“失效”？

        父容器高度不足、父容器没有滚动、或被 overflow: hidden 限制时 sticky 可能不起作用。

        3. fixed 和 sticky 的区别？

        fixed 始终相对视口固定，sticky 只在滚动到阈值位置后才固定。
    * ***CSS 优先级计算规则***
        1. 优先级权重计算公式

        用四元组 (a, b, c, d) 表示优先级，按从高到低依次比较：

        a → 是否`内联样式`（直接写在元素的 style 属性中），有则 a=1，否则 a=0

        b → 选择器中 `ID 选择器` 的数量

        c → 选择器中 `类、属性选择器、伪类` 的数量

        d → 选择器中 `标签选择器、伪元素` 的数量

        2. 权重比较规则

        先比 a，再比 b，再比 c，再比 d，数值大的优先级高。

        例如：

        #id .class div   => (0, 1, 1, 1)
        .class div       => (0, 0, 1, 1)


        第一个优先级更高。

        3. 特殊规则

        `!important` 权重最高（但仅覆盖同属性的其他声明，不改变选择器优先级）。

        继承的样式优先级最低，不影响权重计算。

        通配选择器 * 权重最低（0,0,0,0）。

        伪类（:hover、:nth-child）算在 c，伪元素（::before、::after）算在 d。

        4. 优先级排序（从高到低）

        !important（同层级比较）

        内联样式（a=1）

        ID 选择器（b）

        类、属性、伪类选择器（c）

        标签、伪元素选择器（d）

        继承与通配符

        5. 总结技巧

        避免过度依赖 !important，会破坏样式维护性。

        合理利用层叠性（cascade）和结构优化，而不是单纯堆高权重选择器。

    - *延伸问题*：
        1. 如果两个规则权重一样，哪个生效？

        后写的（在 CSS 中位置靠后的）生效，因为 CSS 遵循“后声明覆盖前声明”的层叠原则。

        2. !important 能被覆盖吗？

        只有另一个同属性且带 !important 且优先级更高的选择器可以覆盖。

        3. 为什么避免滥用 ID 选择器？

        权重过高会影响样式复用性，难以覆盖。
2. **JavaScript**

    * ***JavaScript 数据类型与类型转换***
        1. 数据类型分类

        基本类型（Primitive Types）：
        `number`、`string`、`boolean`、`null`、`undefined`、`symbol`（ES6）、`bigint`（ES2020）

        引用类型（Reference Types）：
        `object`（包括 Array、Function、Date、RegExp 等）

        2. 类型判断方法

        typeof：能区分基本类型，但 typeof null === 'object' 是历史遗留问题。

        instanceof：判断对象是否由某个构造函数创建（受原型链影响）。

        `Object.prototype.toString.call(value)`：返回精确类型字符串，如 [object Array]。

        3. 类型转换

        显式转换：

            转数字：Number()、parseInt()、parseFloat()、+value

            转字符串：String()、value.toString()、模板字符串 `${value}`

            转布尔：Boolean(value)、!!value

        隐式转换：

            数字运算：'5' - 1 → 4（字符串被转为数字）

            字符串拼接：'5' + 1 → '51'（数字转为字符串）

            条件判断：if (value) 会触发 ToBoolean 转换

        4. 特殊值转换规则（常考）

            Number(null) → 0

            Number(undefined) → NaN

            Number(true) → 1 / Number(false) → 0

            [] 转数字 → 0，转字符串 → ""

            [1,2] 转数字 → NaN，转字符串 → "1,2"

            {} 转数字 → NaN，转字符串 → "[object Object]"
    - *延伸问题*
        1. 为什么 typeof null === 'object'？

        因为早期 JS 的类型标识使用二进制存储，低位是 000 表示对象类型，null 的二进制全是 0，因此被误判为对象。

        2. [] == ![] 为什么是 true？

        ![] → false → 转数字 0

        [] 转数字也是 0，所以 0 == 0 → true

        3. 判断数组的正确方式？

        Array.isArray(arr) 或 Object.prototype.toString.call(arr) === '[object Array]'

    * ***JavaScript 原型与原型链***
        1. 原型（prototype）

        每个 `函数` 在创建时都会自动生成一个 `prototype` 属性，指向一个对象，这个对象就是它的原型对象。

        原型对象上存放可以被该函数的所有实例共享的属性和方法。

        实例对象内部有一个 __proto__（非标准，但几乎所有浏览器都支持），它指向创建该实例的构造函数的 prototype。

        2. 原型链（prototype chain）

        当访问一个对象的属性或方法时，JS 会先在对象自身查找，如果找不到，就沿着 __proto__ 向上查找，直到 Object.prototype，再找不到就返回 undefined。

        这种由多个对象通过原型相连形成的链条就是原型链。

        3. 终点

        原型链的顶端是 Object.prototype，它的 __proto__ 为 null。

        4. 示例
        ```js
            function Person(name) {
            this.name = name;
            }
            Person.prototype.sayHi = function() {
            console.log(`Hi, I'm ${this.name}`);
            };

            const p = new Person('Kaykay');
            p.sayHi(); // 从 p 自身找不到 sayHi → 找到 Person.prototype.sayHi
        ```

        5. 特点与作用

            节省内存：方法定义在原型上，实例共享，不会重复创建。

            实现继承：通过原型链可以实现属性和方法的继承。
    - *延伸问题*
        1. __proto__ 和 prototype 的区别？

            prototype 是函数的属性，用于定义实例的原型；

            __proto__ 是实例对象的属性，指向构造函数的原型对象。

        2. 如何实现继承？

            原型链继承、构造函数继承、组合继承、ES6 class extends。

        3. p.hasOwnProperty() 的作用？

            判断属性是否存在于对象本身而非原型链上。

        4. 修改原型的注意点？

            修改 prototype 会丢失原有的 constructor，需要手动恢复。
   * ***this 的绑定规则（默认、隐式、显式、new）***
   * ***Event Loop 运行机制（含微任务/宏任务执行顺序）***
   * ***深拷贝与浅拷贝实现***
   * ***防抖与节流的区别及实现***

3. **Vue 相关**

   * Vue3 响应式原理（Proxy vs Object.defineProperty）
   * 虚拟 DOM 与 diff 算法（双端 diff 流程）
   * 组件通信方式对比（props/emit、provide/inject、Pinia）
   * v-if / v-show 区别与使用场景
   * Vue3 的性能优化手段（v-memo、PatchFlags）

---

### **模块 2：项目延伸问题**

> **目标**：让你能从简历出发，答到深度

1. **地理空间数据与模型科研工作平台**

   * 如何衡量“组件复用率”？
   * 为什么复用率不是 100%，如何进一步提升？
   * 分片上传的分片大小如何选择？断点续传如何实现？
   * WebSocket 如何保证消息有序与断线重连？
   * 大语言模型集成的安全性与性能优化怎么做？

2. **多轨道演播系统**

   * 轨道渲染卡顿的原因与优化方法？
   * 多媒体素材时间轴同步的实现思路？
   * 自动字幕生成的核心技术路线？

3. **长江洲滩崩岸预警系统**

   * 实时监测数据的可视化渲染如何避免卡顿？
   * 模型参数配置如何自动化？
   * 如何减少对专家经验的依赖，提高预测准确率？

---

### **模块 3：GIS / Mapbox 专项**

> **目标**：利用你独特的地图开发经验加分

1. Mapbox 数据源类型（GeoJSON、Vector、Raster）的区别与应用场景
2. 高性能渲染大数据点的优化方案（cluster、geojson-vt、Web Worker）
3. 坐标系转换（WGS84 ↔ Web Mercator）
4. 如何在 Mapbox 上实现热力图，并优化性能
5. 如何处理实时地图数据更新的闪烁与延迟问题

---

### **模块 4：工程化与性能优化**

> **目标**：应对中高年资面试官的工程思维追问

1. Vite 和 Webpack 的差异与打包优化策略
2. 前端 CI/CD 流程如何搭建？
3. 浏览器缓存策略（强缓存 vs 协商缓存）
4. 懒加载与预加载的区别与实现
5. 如何监控并优化首屏性能（FP、FCP、LCP、TTI）？

---

### **模块 5：算法与代码实现**

> **目标**：应对白板/在线编程环节

1. 数组类

   * 两数之和（Two Sum）
   * 滑动窗口求最大子数组和
   * 数组去重（Set / 双指针）

2. 字符串类

   * 反转单词顺序（LC151）
   * 最长不重复子串（LC3）
   * 字符串压缩（aabcc → a2b1c2）

3. 数据结构类

   * LRU 缓存实现
   * 用两个栈实现队列
   * 二叉树的层序遍历

4. 模拟类

   * 大整数加法
   * 括号匹配检测
   * 合并区间

---

### **模块 6：思维题 / 产品八股文**

> **目标**：应对业务面试官的估算题、开放题

1. 估算北京一天的外卖订单量
2. 设计一个前端文件上传系统，支持断点续传和秒传
3. 如何设计一个前端埋点方案，统计页面停留时长和用户行为
4. 如果要支持地图上 10 万个点的实时渲染，你会怎么设计？

