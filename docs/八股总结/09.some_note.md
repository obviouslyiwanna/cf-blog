## **专项面试题清单**

### **模块 1：前端基础与原理**

> **目标**：保证基础扎实，应对高频原理题和追问

1.  **HTML/CSS**

    - **_盒模型_**
      在浏览器中，盒模型（Box Model）描述了一个元素的大小由哪些部分组成。

      1. 标准盒模型（content-box，W3C 盒模型）

      width / height 只包含 内容区域（content） 的宽高。

      元素的总宽度 = content + padding + border + margin。

      2. 怪异盒模型（border-box，IE 盒模型）

      width / height 包含 内容 + 内边距（padding） + 边框（border），不包含 margin。

      内容区域大小 = width - padding - border。

      3. 切换方式

      通过 box-sizing 属性控制：

      box-sizing: content-box → 标准盒模型（默认值）

      box-sizing: border-box → 怪异盒模型

      4. 使用场景

      标准盒模型更符合传统的 CSS 规范，计算内容大小时直观。

      怪异盒模型在做自适应布局时更方便，比如固定宽度的卡片，内部 padding 不会撑破布局。

      5. 总结

      两种盒模型的差异在于 width/height 的计算范围，了解差异有助于避免布局错位和尺寸计算错误。

    * _延伸问题_：

      1. 如何在全局设置所有元素为怪异盒模型？为什么这么做？
         可以通过 CSS 重置（reset.css）或全局样式（global.css）设置所有元素为怪异盒模型。
         例如：

      ```css
      * {
        box-sizing: border-box;
      }
      ```

      这么做的好处是避免计算 padding/border 时撑破布局，减少尺寸计算复杂度。 2. 如何判断某个元素当前的盒模型类型？
      可以通过 getComputedStyle 方法获取元素的当前计算样式，其中 box-sizing 就是其中之一。

      ```js
      getComputedStyle(element).boxSizing
      ```

      3. margin 塌陷（Margin Collapse）与盒模型的关系？

      margin 塌陷是垂直方向相邻块元素外边距的合并，与盒模型定义不同，但布局时可能一起影响结果。

    - **_BFC 原理及应用场景_**

      1. 定义
         BFC（Block Formatting Context）是页面中的一个独立渲染区域，在该区域中，元素的布局不受外部元素影响，并且也不会影响外部的布局。

      2. 特性

      内部的元素会在垂直方向一个接一个排列。

      BFC 区域与外部元素的 margin 不会发生折叠。

      BFC 区域不会与浮动元素重叠，会将浮动元素“包裹”起来。

      计算 BFC 高度时会包含浮动元素的高度。

      3. 常见触发方式（任一满足即可）

      float 的值不为 none

      position 为 absolute 或 fixed

      display 为 inline-block、table-cell、table-caption、flex、inline-flex、grid、inline-grid

      overflow 的值不为 visible（如 hidden、auto、scroll）

      4. 应用场景

      清除浮动：父元素触发 BFC，可以自动包裹内部浮动子元素，避免高度塌陷。

      防止 margin 合并：相邻块元素如果在不同 BFC 中，margin 不会合并。

      布局隔离：让某块布局不受外部影响，比如防止文字环绕浮动图片。

      5. 总结
         BFC 是 CSS 中重要的布局概念，理解它的触发条件和特性可以解决常见的浮动、塌陷、布局错位等问题。

    * _延伸问题_：

      1. BFC 与 IFC（行内格式化上下文）的区别？

      BFC 内元素是块级布局，IFC 内元素是行内布局（文字、行内块等）。

      2. 清除浮动还有哪些方法？BFC 相比之下的优缺点？

      其他方法如 clear: both、伪元素清除法（.clearfix::after）。

      BFC 不会额外增加 DOM，也不依赖额外 CSS 选择器，较为简洁。

      3. overflow: hidden 触发 BFC 的副作用？

      可能裁剪超出容器的内容。

    - **_浮动（float）与清除浮动_**

      1. 定义与原理

      float 最初设计用于让文字环绕图片（比如图文排版），会让元素脱离标准文档流（不占据原来的块级位置），但仍然保留在所在容器的文本流中。

      浮动元素会向左或向右移动，直到碰到父容器边界或另一个浮动元素。

      2. 特性

      浮动元素不再占据标准流位置，但会影响其后的行内内容（文字、inline 元素会围绕它排布）。

      块级元素如果没触发 BFC 或没清除浮动，不会自动包裹浮动元素的高度 → 产生高度塌陷。 3. 清除浮动的方法

      CSS clear 属性

      ```css
      .clearfix {
        clear: both; /* 清除左右浮动的影响 */
      }
      ```

      伪元素法（推荐）

      ```css
      .clearfix::after {
        content: '';
        display: block;
        clear: both;
      }
      ```

      触发 BFC（如 overflow: hidden）

      父元素触发 BFC 后会自动包含浮动子元素的高度。

      4. 现代布局趋势

      现在布局多用 Flexbox 或 Grid 代替 float，因为它们更灵活、可控。

      float 主要用于简单图文混排或兼容旧项目。

    - **_display 的常见取值及区别_**

      1. block（块级元素）

      独占一行，默认宽度撑满父容器，高度由内容决定。

      可以设置 width/height、margin/padding。

      常见如 `<div>、<p>、<section>`。

      2. inline（行内元素）

      与其他行内元素在同一行内显示，宽高由内容撑开，不能直接设置宽高。

      padding/margin 在水平方向有效，垂直方向可能不生效。

      常见如` <span>、<a>、<em>`。

      3. inline-block（行内块）

      像 inline 一样不独占一行，但可以像 block 一样设置宽高、padding、margin。

      常用于水平排列的可设置尺寸的元素（如按钮组）。

      4. flex（弹性布局）

      父元素设 display: flex，子元素变成 flex items，支持主轴/交叉轴对齐、空间分配、伸缩。

      适合一维布局（水平或垂直）。

      5. grid（网格布局）

      父元素设 display: grid，子元素按网格行列布局，可精确控制行高列宽。

      适合二维布局。

      6. table / table-cell / table-row

      模拟表格布局，可按表格单元格规则排列内容，适合某些需要等高列的场景。

      7. none

      元素不显示且不占据空间（与 visibility: hidden 区别在于不占位）。

    * _延伸问题_：

      1. inline 和 inline-block 的区别？

      inline-block 可设置宽高，inline 不行。

      2. flex 和 grid 的适用场景区别？

      flex 适合一维（主轴优先），grid 适合二维（行列同时控制）。

      3. 如何让两个 div 在一行内等高排列？

      flex（align-items: stretch）或 grid（行高自动拉伸）。

    - **_重排（Reflow）与重绘（Repaint）的触发条件与优化手段_**

      1. 定义

      重排（Reflow / Layout）：当元素的几何尺寸（宽、高、位置）发生变化，浏览器需要重新计算布局并重新渲染。

      重绘（Repaint）：当元素的外观样式（颜色、背景、阴影等）发生变化，但几何尺寸不变时，只需重新绘制，不重新计算布局。

      2.  触发条件
          重排常见触发：

              添加/删除 DOM 元素

              元素尺寸、位置变化（width、height、margin、padding、top/left 等）

              浏览器窗口大小变化（触发响应式布局）

              获取布局信息（offsetTop、offsetHeight、getComputedStyle() 等）

      重绘常见触发：

            修改背景色、文字颜色

            改变 visibility（但 display:none 会触发重排）

            添加/修改 box-shadow

      关系：

            重排一定会引发重绘，但重绘不一定会引发重排。

      3. 性能优化手段

      减少重排次数

            样式集中修改：批量更改样式或使用 class 切换，而不是多次修改单个样式属性。

            使用文档片段（DocumentFragment）批量插入 DOM。

            元素离线处理：对要频繁操作的元素使用 display:none（触发一次重排，隐藏后修改不再触发），修改完成再显示。

            避免频繁读取布局信息（会强制触发回流），可先缓存结果。

      减少重绘开销

            尽量合并视觉修改，比如动画中用 transform 和 opacity（GPU 加速）替代直接修改位置和背景。

            避免复杂 CSS 选择器导致重绘范围大。

      4. 总结

      重排影响更大，应优先优化，避免频繁修改布局属性。

      动画尽量用 `transform` 和 `opacity`，它们不会触发重排（通常只触发合成层变化）。

    * _延伸问题_：

      1. visibility: hidden 和 display: none 对性能的影响？

      display:none 触发重排，visibility:hidden 只触发重绘。

      2. 为什么频繁读取 offsetHeight 会影响性能？

      会强制浏览器刷新渲染队列（flush），立刻计算最新布局，阻塞渲染线程。

      3. 如何优化高频动画的性能？

      用 transform: translateZ(0) 开启 GPU 加速，避免 layout 阶段参与。

    - **_position: float/absolute/fixed/sticky 区别_**

      1. float（浮动）

      让元素脱离标准文档流，但仍处于文本流中，会影响周围的 inline 内容（如文字环绕）。

      按 left 或 right 浮动，直到碰到父容器的边界或另一个浮动元素。

      常用于文字环绕图片或老式布局，现在多用 flex/grid 替代。

      2. absolute（绝对定位）

      完全脱离文档流，不占据原位置，也不影响其他元素布局。

      参考对象：离它最近的 position 不为 static 的祖先元素；如果找不到，就相对 初始包含块（通常是 html/body）。

      常用于精确摆放元素（弹窗、按钮等）。

      3. relative（相对定位）

      不脱离文档流，仍占据原本位置，但可以通过 top/left/right/bottom 相对自己原位置偏移。

      偏移后，原本的位置仍保留（周围元素不受影响）。

      常用于微调元素位置，或者给子元素 absolute 提供参考定位点。

      4. sticky（粘性定位）

      结合了 relative 和 fixed 的特性：在达到设定的偏移阈值前是相对定位，达到阈值后会固定在视口位置。

      参考对象：最近的可滚动祖先元素的滚动区域。

      常用于表头固定、导航条吸顶等效果。
      \| 定位方式 | 脱离文档流 | 参考对象 | 常用场景 |

      > \| 定位方式 | 脱离文档流 | 参考对象 | 常用场景 |
      > \| float | 是（部分） | 父容器宽度 | 图文混排、旧布局 |
      > \| absolute | 是 | 最近的非 static 祖先 | 精确定位 |
      > \| relative | 否 | 自己原位置 | 微调位置、定位参考点 |
      > \| sticky | 否（初期） | 最近的可滚动祖先 | 吸顶、固定表头 |

    * _延伸问题_：

      1. absolute 的参考对象具体是怎么算的？

      从当前元素向上找第一个 position 不为 static 的祖先元素。

      2. sticky 为什么有时“失效”？

      父容器高度不足、父容器没有滚动、或被 overflow: hidden 限制时 sticky 可能不起作用。

      3. fixed 和 sticky 的区别？

      fixed 始终相对视口固定，sticky 只在滚动到阈值位置后才固定。

    - **_CSS 优先级计算规则_**

      1. 优先级权重计算公式

      用四元组 (a, b, c, d) 表示优先级，按从高到低依次比较：

      a → 是否`内联样式`（直接写在元素的 style 属性中），有则 a=1，否则 a=0

      b → 选择器中 `ID 选择器` 的数量

      c → 选择器中 `类、属性选择器、伪类` 的数量

      d → 选择器中 `标签选择器、伪元素` 的数量

      2. 权重比较规则

      先比 a，再比 b，再比 c，再比 d，数值大的优先级高。

      例如：

      #id .class div => (0, 1, 1, 1)
      .class div => (0, 0, 1, 1)

      第一个优先级更高。

      3. 特殊规则

      `!important` 权重最高（但仅覆盖同属性的其他声明，不改变选择器优先级）。

      继承的样式优先级最低，不影响权重计算。

      通配选择器 \* 权重最低（0,0,0,0）。

      伪类（:hover、:nth-child）算在 c，伪元素（::before、::after）算在 d。

      4. 优先级排序（从高到低）

      !important（同层级比较）

      内联样式（a=1）

      ID 选择器（b）

      类、属性、伪类选择器（c）

      标签、伪元素选择器（d）

      继承与通配符

      5. 总结技巧

      避免过度依赖 !important，会破坏样式维护性。

      合理利用层叠性（cascade）和结构优化，而不是单纯堆高权重选择器。

    * _延伸问题_：

      1. 如果两个规则权重一样，哪个生效？

      后写的（在 CSS 中位置靠后的）生效，因为 CSS 遵循“后声明覆盖前声明”的层叠原则。

      2. !important 能被覆盖吗？

      只有另一个同属性且带 !important 且优先级更高的选择器可以覆盖。

      3. 为什么避免滥用 ID 选择器？

      权重过高会影响样式复用性，难以覆盖。

2.  **JavaScript**

    - **_JavaScript 数据类型与类型转换_**

      1. 数据类型分类

      基本类型（Primitive Types）：
      `number`、`string`、`boolean`、`null`、`undefined`、`symbol`（ES6）、`bigint`（ES2020）

      引用类型（Reference Types）：
      `object`（包括 Array、Function、Date、RegExp 等）

      2. 类型判断方法

      typeof：能区分基本类型，但 typeof null === 'object' 是历史遗留问题。

      instanceof：判断对象是否由某个构造函数创建（受原型链影响）。

      `Object.prototype.toString.call(value)`：返回精确类型字符串，如 [object Array]。

      3. 类型转换

      显式转换：

            转数字：Number()、parseInt()、parseFloat()、+value

            转字符串：String()、value.toString()、模板字符串 `${value}`

            转布尔：Boolean(value)、!!value

      隐式转换：

            数字运算：'5' - 1 → 4（字符串被转为数字）

            字符串拼接：'5' + 1 → '51'（数字转为字符串）

            条件判断：if (value) 会触发 ToBoolean 转换

      4. 特殊值转换规则（常考）

         Number(null) → 0

         Number(undefined) → NaN

         Number(true) → 1 / Number(false) → 0

         [] 转数字 → 0，转字符串 → ""

         [1,2] 转数字 → NaN，转字符串 → "1,2"

         {} 转数字 → NaN，转字符串 → "[object Object]"

    * _延伸问题_

      1. 为什么 typeof null === 'object'？

      因为早期 JS 的类型标识使用二进制存储，低位是 000 表示对象类型，null 的二进制全是 0，因此被误判为对象。

      2. [] == ![] 为什么是 true？

      ![] → false → 转数字 0

      [] 转数字也是 0，所以 0 == 0 → true

      3. 判断数组的正确方式？

      Array.isArray(arr) 或 Object.prototype.toString.call(arr) === '[object Array]'

    - **_JavaScript 原型与原型链_**

      1. 原型（prototype）

      每个 `函数` 在创建时都会自动生成一个 `prototype` 属性，指向一个对象，这个对象就是它的原型对象。

      原型对象上存放可以被该函数的所有实例共享的属性和方法。

      实例对象内部有一个 **proto**（非标准，但几乎所有浏览器都支持），它指向创建该实例的构造函数的 prototype。

      2. 原型链（prototype chain）

      当访问一个对象的属性或方法时，JS 会先在对象自身查找，如果找不到，就沿着 **proto** 向上查找，直到 Object.prototype，再找不到就返回 undefined。

      这种由多个对象通过原型相连形成的链条就是原型链。

      3. 终点

      原型链的顶端是 Object.prototype，它的 **proto** 为 null。

      4. 示例

      ```js
      function Person(name) {
        this.name = name
      }
      Person.prototype.sayHi = function () {
        console.log(`Hi, I'm ${this.name}`)
      }

      const p = new Person('Kaykay')
      p.sayHi() // 从 p 自身找不到 sayHi → 找到 Person.prototype.sayHi
      ```

      5. 特点与作用

         节省内存：方法定义在原型上，实例共享，不会重复创建。

         实现继承：通过原型链可以实现属性和方法的继承。

    * _延伸问题_

      1. **proto** 和 prototype 的区别？

         prototype 是函数的属性，用于定义实例的原型；

         **proto** 是实例对象的属性，指向构造函数的原型对象。

      2. 如何实现继承？

         原型链继承、构造函数继承、组合继承、ES6 class extends。

      3. p.hasOwnProperty() 的作用？

         判断属性是否存在于对象本身而非原型链上。

      4. 修改原型的注意点？

         修改 prototype 会丢失原有的 constructor，需要手动恢复。

    - **_this 的绑定规则（默认、隐式、显式、new）_**

      1. this 的绑定规则（从优先级高到低）

      - new 绑定

      如果函数通过 new 调用，this 绑定到新创建的对象。

      ```js
      function Foo(name) {
        this.name = name
      }
      const a = new Foo('Kaykay') // this → a
      ```

      - 显示绑定（call / apply / bind）

      通过 call / apply / bind 显式指定 this。

      ```js
      function greet() {
        console.log(this.name)
      }
      greet.call({ name: 'Kaykay' }) // Kaykay
      ```

      - 隐式绑定

      通过对象调用方法，this 绑定到该对象。

      ```js
      const obj = {
        name: 'Kaykay',
        say() {
          console.log(this.name)
        }
      }
      obj.say() // Kaykay
      ```

      - 默认绑定

      普通函数调用，非严格模式下 this 绑定到全局对象（浏览器中是 window），严格模式下绑定为 undefined。

      ```js
      function test() {
        console.log(this)
      }
      test() // 浏览器中 → window（非严格模式）
      ```

      2. 特殊情况

      箭头函数的 this 不绑定自己的 this，而是继承定义时外层作用域的 this（词法绑定）。

      事件监听器中，this 默认指向绑定事件的元素（但用箭头函数时继承外层作用域）。

      3. 绑定优先级

      `new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定`

      但箭头函数例外，它的 this 一旦绑定就无法被改变（call/apply/bind 无效）。

      常见陷阱

      ```js
      var name = 'global'
      const obj = {
        name: 'obj',
        getName: function () {
          return function () {
            console.log(this.name)
          }
        }
      }
      obj.getName()() // 'global'（默认绑定）
      ```

      解决：用箭头函数或 bind 保留 this。

    * _延伸问题_

        1. 箭头函数的 this 能被 bind 改变吗？

        不能，箭头函数的 this 在定义时就确定了。

        2. 事件监听中的 this 是什么？

        默认是绑定事件的元素，除非用箭头函数或显式绑定。

        3. etTimeout 回调中的 this 是谁？

        默认绑定到全局（非严格模式下），严格模式下是 undefined。

    - **_JavaScript 作用域与作用域链_**

      1. 作用域（Scope）定义

         作用域是变量和函数可访问的范围，它决定了代码在特定位置对变量的访问权限。

      JS 采用词法作用域（静态作用域）：作用域在函数定义时就已经确定，而不是在调用时决定。

      2. 作用域类型

         全局作用域：最外层代码或直接在 script 标签中声明的变量、函数。

         函数作用域：函数内部声明的变量，只能在函数内部访问。

         块级作用域（ES6）：let / const 在 {} 内创建的作用域，例如 if、for。

      3. 作用域链（Scope Chain）

         当访问一个变量时，JS 引擎会先在当前作用域查找，如果找不到，就沿着外层作用域依次向上查找，直到全局作用域；如果仍然找不到，就抛出 ReferenceError。

         这种由多个作用域逐级连接形成的链条就是作用域链。

      4. 示例

      ```js
      const a = 1
      function outer() {
        const b = 2
        function inner() {
          const c = 3
          console.log(a, b, c) // 1, 2, 3
        }
        inner()
      }
      outer()
      ```

      inner 的作用域链：[inner -> outer -> global]

      5. 与闭包的关系

      闭包就是函数和其外部作用域变量的绑定，因此闭包本质上是作用域链被保留的现象。 6. 闭包的作用

      保护变量不被销毁（如私有变量）。

      延长变量的生命周期（如事件处理函数）。

    * _延伸问题_

      1. JS 为什么是词法作用域？

      因为作用域在代码书写（定义）时确定，而不是运行时根据调用位置决定。

      2. 作用域链和原型链的区别？

      作用域链是变量查找的路径，原型链是对象属性查找的路径。

      3. 块级作用域和函数作用域的区别？

      函数作用域只能在整个函数内访问变量；块级作用域只在 {} 内有效。

    - **_Event Loop（事件循环机制）_**

      1. 定义

         Event Loop 是 JS 运行时处理异步任务的机制，它协调**执行栈（call stack）与任务队列（task queues）**的运行顺序。

         JS 是单线程的，但通过 Event Loop 实现异步执行。

      2. 任务类型

         宏任务（Macro Task）：整体 script、setTimeout、setInterval、setImmediate（Node）、I/O、UI 渲染等。

         微任务（Micro Task）：Promise.then/catch/finally、queueMicrotask、MutationObserver。

      3. 执行顺序规则

         执行一个宏任务（最开始是整个 script）。

         执行过程中产生的微任务，全部加入微任务队列。

         宏任务执行结束后，立即清空当前所有微任务队列。

         再从宏任务队列取下一个宏任务执行，重复以上过程。

      4. 示例执行流程

      ```js
      console.log('script start')
      setTimeout(() => console.log('timeout'), 0)
      Promise.resolve().then(() => console.log('promise'))
      console.log('script end')
      ```

             输出：

             script start
             script end
             promise
             timeout


             原因：

             整体 script 是第一个宏任务。

             遇到 setTimeout → 放入宏任务队列（下一轮）。

             遇到 Promise → 放入微任务队列（本轮）。

             宏任务执行完 → 清空微任务（输出 promise）。

             进入下一轮宏任务（输出 timeout）。

      典型输出题

      ```js
      console.log(1)

      setTimeout(() => {
        console.log(2)
        Promise.resolve().then(() => console.log(3))
      }, 0)

      Promise.resolve().then(() => {
        console.log(4)
        setTimeout(() => console.log(5), 0)
      })

      console.log(6)
      ```

      1
      6
      4
      2
      3
      5
      解析：

      第一轮宏任务：1 → 6 → 微任务 4

      第二轮宏任务：2 → 微任务 3

      第三轮宏任务：5

    * _延伸问题_

      1. 为什么微任务要优先执行？

      设计上为了保证一次宏任务中的异步逻辑尽快执行完，不被下一轮宏任务打断。

      2. Node.js 的 Event Loop 有什么不同？

      Node 的 Event Loop 有 6 个阶段（timers、pending callbacks、idle、poll、check、close callbacks），微任务在每个阶段之间执行。

      3. requestAnimationFrame 属于哪种任务？

      属于渲染帧任务，在浏览器渲染前执行，优先级高于宏任务低于微任务。

    - **_深浅拷贝_**

      1. 定义

         浅拷贝（Shallow Copy）：只复制一层对象属性，如果属性是引用类型，仍然指向同一块内存。

         深拷贝（Deep Copy）：不仅复制对象本身，还递归复制其引用类型的属性，生成全新的值，互不影响。

      2. 浅拷贝的实现方式

         Object.assign({}, obj)

         展开运算符 { ...obj }

         Array.prototype.slice() / concat()（数组）

      3. 深拷贝的常见实现

         JSON 方法（简单粗暴，但有局限）

         ```js
         const clone = JSON.parse(JSON.stringify(obj))
         ```

         缺点：

         无法复制函数、undefined、Symbol

         会丢失 Date、RegExp、Map、Set 等特殊对象

         递归遍历（手写深拷贝）

         ```js
         function deepClone(obj, hash = new WeakMap()) {
           if (obj === null || typeof obj !== 'object') return obj
           if (hash.has(obj)) return hash.get(obj) // 处理循环引用
           const clone = Array.isArray(obj) ? [] : {}
           hash.set(obj, clone)
           for (let key in obj) {
             if (obj.hasOwnProperty(key)) {
               clone[key] = deepClone(obj[key], hash)
             }
           }
           return clone
         }
         ```

      第三方库

      Lodash 的 \_.cloneDeep() 性能和兼容性较好。

      4. 使用建议

      如果对象结构简单，用浅拷贝即可，性能更好。

      如果涉及状态管理、不可变数据（如 React），深拷贝更安全，但要注意性能优化。

    * _延伸问题_

      1. 深浅拷贝的性能差异？

      深拷贝递归遍历对象，性能开销比浅拷贝大得多，尤其是大对象。

      2. 如何处理循环引用？

      使用 WeakMap 存储已拷贝对象，防止无限递归。

      3. JSON 方法为什么丢失函数？

      因为 JSON 只能序列化可 JSON 表示的数据类型，函数和特殊对象会被忽略或转成字符串。

    - **_防抖（Debounce）与节流（Throttle）_**

      1. 定义与区别

         防抖（Debounce）：在事件被触发后 等待一段时间，如果期间再次触发，则重新计时。适合高频触发且只需执行一次的场景。

         节流（Throttle）：保证在一段时间内只执行一次，无论触发多少次。适合需要持续响应的场景。

      2. 常见应用场景

         防抖：搜索框输入（只在用户停止输入后发送请求）、窗口 resize（只在结束时计算）

         节流：滚动加载、抢票按钮点击、鼠标移动计算坐标

      3. 实现方式

      防抖（debounce）

      ```js
      function debounce(fn, delay) {
        let timer = null
        return function (...args) {
          clearTimeout(timer)
          timer = setTimeout(() => {
            fn.apply(this, args)
          }, delay)
        }
      }
      ```

      节流（throttle）- 时间戳版

      ```js
      function throttle(fn, wait) {
        let last = 0
        return function (...args) {
          const now = Date.now()
          if (now - last >= wait) {
            fn.apply(this, args)
            last = now
          }
        }
      }
      ```

      节流（throttle）- 定时器版

      ```js
      function throttle(fn, wait) {
        let timer = null
        return function (...args) {
          if (!timer) {
            timer = setTimeout(() => {
              fn.apply(this, args)
              timer = null
            }, wait)
          }
        }
      }
      ```

      4. 对比总结

      特性 防抖 节流
      触发频率 延迟到最后一次触发 固定时间间隔触发一次
      应用场景 输入框、调整窗口大小 滚动监听、拖拽移动
      实现方式 清除+重设定时器 时间戳或定时器控制

    * _延伸问题_

      1. 能否写一个既支持防抖又支持立即执行的 debounce？

      通过加一个 immediate 参数实现。

      2. 节流的时间戳版和定时器版有什么区别？

      时间戳版第一次会立即执行，定时器版会延迟第一次执行。

      3. 防抖和节流在 React / Vue 项目中怎么结合使用？

      常见做法是 lodash 的 _.debounce 和 _.throttle，或自定义 Hook。

    - **_ES6+ 常用特性_**

      1. 块级作用域

         let 和 const 提供了块级作用域，避免了变量提升带来的问题。

         const 用于声明常量（引用类型变量的引用地址不可变，但内容可变）。

      2. 解构赋值（Destructuring）

      从数组或对象中快速提取值：

      ```js
      const [a, b] = [1, 2]
      const { name, age } = { name: 'Kaykay', age: 18 }
      ```

      支持默认值和嵌套解构。

      3. 展开运算符（Spread）与剩余参数（Rest）

      展开运算符：

      ```js
      const arr1 = [1, 2]
      const arr2 = [...arr1, 3] // [1, 2, 3]
      ```

      剩余参数：

      ```js
      function sum(...nums) {
        return nums.reduce((a, b) => a + b, 0)
      }
      ```

      4. 模板字符串（Template Literals）

      支持多行、变量插值：

      ```js
      const msg = `Hello, ${name}!`
      ```

      5. 箭头函数（Arrow Function）

      更简洁语法，不绑定 this（继承外层作用域 this）。

      适合回调，不适合做构造函数或绑定事件需要 this 的场景。

      6. Promise / async / await

      Promise 解决了回调地狱，async/await 让异步代码更像同步写法：

      ```js
      async function fetchData() {
        try {
          const res = await fetch('/api')
          return await res.json()
        } catch (err) {
          console.error(err)
        }
      }
      ```

      7. Map / Set / WeakMap / WeakSet

         Map：键值对集合，键可以是任意类型。

         Set：值的集合，值唯一。

         WeakMap / WeakSet：弱引用，不阻止垃圾回收，适合存储临时对象。

      8. 模块化（Module）

      export / import，支持静态分析与按需加载。

      ```js
      // module.js
      export const a = 1
      // main.js
      import { a } from './module.js'
      ```

    * _延伸问题_

      1. 箭头函数和普通函数的 this 有什么区别？

      箭头函数继承定义时的外层 this，不受调用方式影响。

      2. async/await 如何并发执行多个异步任务？

      用 Promise.all 而不是顺序 await。

      3. Map 和 Object 的区别？

      Map 键可以是任意类型，遍历顺序按插入顺序，性能在大量增删时更优。

3.  **浏览器部分**

    - **_浏览器渲染流程_**

      1. 渲染流程概览（浏览器从收到 HTML 到页面显示的步骤）

         解析 HTML → 构建 DOM 树（Document Object Model）

         解析 CSS → 构建 CSSOM 树（CSS Object Model）

         DOM + CSSOM 合并 → 生成 渲染树（Render Tree）（只包含可见节点）

         布局（Layout）：计算每个节点的大小和位置（也叫回流 Reflow）

         分层（Layering）：复杂元素单独生成图层（如 3D、动画、z-index 高的元素）

         绘制（Painting）：将每个图层绘制成位图（Repaint）

         合成（Compositing）：将多个图层合成到屏幕上

      2. 关键概念

         Reflow（回流/重排）：元素的几何尺寸或位置变化，需要重新计算布局。

         Repaint（重绘）：元素外观（颜色、背景）变化，不影响布局，只需重新绘制。

         回流必定引起重绘，重绘不一定引起回流。

      3. 性能优化切入点

      减少回流次数：

            批量修改 DOM（如用 documentFragment）

            避免逐帧触发样式计算（比如 offsetTop/getComputedStyle 后立即改样式）

            对频繁变化的元素使用 position: absolute/fixed 脱离文档流

      减少重绘：

            合理使用 visibility: hidden 替代 display: none（只重绘，不回流）

            利用 GPU 加速：

            对动画元素加 will-change: transform 或 transform: translateZ(0)，让它单独成层，避免频繁回流

      4. 常见面试题回答模板

      浏览器渲染流程是：解析 HTML 生成 DOM → 解析 CSS 生成 CSSOM → 合并成渲染树 → 布局（回流）→ 分层 → 绘制（重绘）→ 合成。
      性能优化可以从减少 DOM 操作、避免强制同步布局、利用合成层等方向切入。

    * _延伸问题_

      1. 为什么操作 DOM 慢？

      DOM 操作涉及渲染树构建和布局计算，频繁修改会导致多次回流和重绘。

      2. 如何批量更新 DOM 而不频繁触发回流？

      用 documentFragment、display: none 隐藏后修改、虚拟 DOM 等方法。

      3. CSS 哪些属性会触发回流/重绘？

      回流：width、height、margin、padding、position 等布局相关属性

      重绘：color、background、visibility 等外观属性

    - **_前端性能优化_**

      1. 性能优化总体思路

      从 加载性能、渲染性能、交互性能 三个维度切入，目标是提升首屏速度、减少卡顿、优化用户体验。

      2. 加载性能优化（减少白屏时间）

         资源压缩与合并：HTML/CSS/JS 压缩、雪碧图（减少请求数）

         按需加载（Code Splitting）：路由懒加载、组件懒加载

         缓存优化：HTTP 缓存（Cache-Control、ETag）、Service Worker 缓存

         CDN 加速：将静态资源分发到离用户最近的节点

         减少 DNS 查询：DNS 预解析（<link rel="dns-prefetch">）

      3. 渲染性能优化（减少卡顿）

         减少回流/重绘：批量操作 DOM，减少样式计算

         合成层加速：will-change、transform: translateZ(0)

         使用虚拟列表（Virtual List）：处理长列表渲染

         图片优化：懒加载、WebP/AVIF 格式、响应式图片（srcset）

      4. 交互性能优化（保持流畅）

         防抖与节流：限制高频事件执行（scroll、resize、input）

         Web Worker：将计算密集型任务放到子线程

         requestAnimationFrame：动画帧同步渲染

      5. 性能监控与评估

         指标：FP（First Paint）、FCP（First Contentful Paint）、LCP（Largest Contentful Paint）、TTI（Time to Interactive）

         工具：Chrome Performance、Lighthouse、WebPageTest

      6. 总结

         性能优化可以从加载、渲染、交互三个方向入手：
         加载上，我会用代码分割、懒加载、HTTP 缓存、CDN。
         渲染上，我会减少回流重绘、使用合成层、图片懒加载和虚拟列表。
         交互上，我会用防抖节流、Web Worker、requestAnimationFrame。
         最终用 Lighthouse 做量化评估，保证关键性能指标达标。

    * _延伸问题_

      1. 如何优化首屏渲染速度？

      预渲染（Prerender）、SSR（服务端渲染）、骨架屏（Skeleton Screen）、Critical CSS

      2. 如何优化长列表渲染？

      虚拟滚动（virtual scrolling）、懒加载、分批渲染

      3. 如何在 React/Vue 项目中避免不必要的渲染？

         React：React.memo、useMemo、useCallback

         Vue：v-if/v-show 合理使用、keep-alive、计算属性缓存

    - **_浏览器安全_**

      1. XSS（Cross-Site Scripting，跨站脚本攻击）

      定义：攻击者向网页注入恶意脚本（JS/HTML），在用户浏览时执行。

      分类：

            存储型：恶意代码存储在服务端数据库（留言板、评论区）。

            反射型：恶意代码通过 URL 等方式传入，立即在页面执行。

            DOM 型：前端 JS 在解析用户输入时不安全地执行。

      防御措施：

            对输入进行过滤和转义（如转义 < > & " ' 等特殊字符）。

            输出时做 HTML Encode。

            使用 CSP（Content Security Policy） 限制可执行脚本来源。

            避免直接用 innerHTML 插入用户输入。

      2. CSRF（Cross-Site Request Forgery，跨站请求伪造）

      定义：攻击者引诱用户访问恶意网站，利用用户已登录的身份，在后台发起伪造请求。

      防御措施：

            CSRF Token 验证：每个请求带上不可预测的 token，并验证。

            SameSite Cookie：限制第三方网站携带 Cookie。

            验证请求来源（Referer / Origin 头）。

      3. 点击劫持（Clickjacking）

      定义：攻击者用透明 iframe 覆盖在页面上，引诱用户点击。

      防御措施：

            设置响应头：X-Frame-Options: DENY 或 SAMEORIGIN。

      4. 其他常见安全风险

         HTTP 劫持：使用 HTTPS 全站加密，防止流量篡改。

         SQL 注入：后端使用参数化查询。

         本地存储泄露：敏感信息避免存储在 localStorage，使用 HttpOnly Cookie。

      5. 总结

         前端安全主要关注 XSS 和 CSRF。
         XSS 是恶意脚本注入，我会在输入输出时做转义，并用 CSP 限制脚本来源。
         CSRF 是利用用户已登录状态发起伪造请求，我会用 CSRF Token、SameSite Cookie 防御。
         其他风险如点击劫持，我会加 X-Frame-Options 头，HTTP 劫持则用 HTTPS 防护。

    * _延伸问题_

      1. CSP 是怎么限制 XSS 的？

      可以通过 Content-Security-Policy 响应头，指定脚本、图片、样式的合法来源，阻止内联脚本执行。

      2. CSRF 和 XSS 有什么关系？

      XSS 是注入脚本，CSRF 是伪造请求；但 XSS 可以用来发起 CSRF 攻击。

      3. SameSite 有几种模式？

      Strict（完全禁止跨站携带 Cookie）、Lax（部分跨站 GET 可带 Cookie）、None（允许跨站但必须 Secure）。

    - **_HTTP / HTTPS_**

      1. HTTP 基本特点

         无状态：每个请求独立，服务器不保存客户端状态（可用 Cookie / Session / Token 维持会话）。

         无连接：请求完成即断开连接（HTTP/1.1 引入了 keep-alive 可复用连接）。

         基于 请求-响应 模型，通常运行在 TCP 之上。

      2. 常见 HTTP 方法

         GET：获取资源（幂等）

         POST：提交资源（非幂等）

         PUT：整体更新资源（幂等）

         PATCH：局部更新资源

         DELETE：删除资源

      3. HTTP 状态码分类

         1xx：信息（请求已接收，继续处理）

         2xx：成功（200 OK，201 Created）

         3xx：重定向（301 永久，302 临时，304 缓存）

         4xx：客户端错误（400 参数错误，401 未认证，403 禁止，404 未找到）

         5xx：服务器错误（500 内部错误，502 网关错误）

      4. HTTP 缓存机制

         强缓存（无需请求服务器）：Expires（绝对时间）、Cache-Control（max-age 相对时间）

         协商缓存（需服务器验证）：Last-Modified / If-Modified-Since、ETag / If-None-Match

      5. HTTPS（HTTP + SSL/TLS）

      作用：加密传输、防篡改、防伪造身份。

      握手过程：

            客户端发起请求，携带支持的加密套件列表。

            服务器返回数字证书（含公钥）。

            客户端验证证书，生成对称密钥并用公钥加密发送给服务器。

            双方使用对称密钥加密后续数据传输。

      性能优化：开启 HTTP/2（多路复用、头部压缩）或 HTTP/3（基于 QUIC，减少握手延迟）。

      6. 总结

         HTTP 是无状态的请求-响应协议，可通过 Cookie/Session/Token 维持会话。
         常用方法有 GET/POST/PUT/PATCH/DELETE，缓存机制包括强缓存和协商缓存。
         HTTPS 在 HTTP 基础上加了 TLS/SSL，通过非对称加密交换对称密钥，保证数据加密、防篡改、防伪造身份。
         性能上可以通过 HTTP/2 多路复用和 HTTP/3 的 QUIC 进一步优化。

    * _延伸问题_

      1. HTTP/1.1、HTTP/2、HTTP/3 区别？

         HTTP/1.1：长连接（keep-alive）、管线化，但有队头阻塞问题。

         HTTP/2：二进制分帧、多路复用、头部压缩、服务端推送。

         HTTP/3：基于 QUIC（UDP），减少握手延迟，解决 TCP 队头阻塞。

      2. HTTPS 如何防止中间人攻击？

      依赖数字证书和 CA 签名，客户端验证证书合法性，防止伪造。

      3. HTTP 缓存如何强制刷新？

      在 URL 后加随机参数，或用 Cache-Control: no-cache 强制协商缓存。

    - **_跨域与 CORS_**

      1. 什么是跨域？

      浏览器 同源策略（Same-Origin Policy） 限制了不同源之间的资源访问，防止恶意网站窃取数据。

      “同源”指 `协议、域名、端口` 三者完全相同。

      跨域的常见表现：前端 JS 调用 API 时，控制台报 No 'Access-Control-Allow-Origin' header。

      2. 常见跨域场景

      http://a.com 调用 http://b.com 接口

      端口不同：http://a.com:8080 调用 http://a.com:3000

      协议不同：http:// 调用 https://

      3. CORS（跨域资源共享）

      通过在服务器设置 HTTP 响应头，告诉浏览器该请求允许跨域访问。

      关键响应头：

            Access-Control-Allow-Origin: http://a.com（或 *）

            Access-Control-Allow-Methods: GET,POST,PUT,DELETE

            Access-Control-Allow-Headers: Content-Type, Authorization

            Access-Control-Allow-Credentials: true（允许携带 Cookie）

      简单请求：GET/POST（表单类型）、HEAD，不触发预检。

      预检请求（OPTIONS）：其他请求方法或自定义头，会先发送 OPTIONS 请求确认是否允许。

      4. 常见跨域解决方案

         后端设置 CORS（主流、推荐）

         反向代理：在同源服务转发 API 请求（如 nginx、webpack devServer）

         JSONP（仅支持 GET，已较少使用）

         postMessage：跨窗口/iframe 传递数据

         WebSocket：不受同源策略限制

      5. 总结

         浏览器出于安全考虑有同源策略，跨域是指协议、域名、端口任一不同导致前端无法直接访问资源。
         主流解决方案是 CORS，通过设置 Access-Control-Allow-Origin 等响应头允许跨域。
         复杂请求会触发 OPTIONS 预检，服务器需正确响应。
         其他方案还有反向代理、JSONP、postMessage、WebSocket 等。

    * _延伸问题_

      1. \*CORS 中 Access-Control-Allow-Origin 为什么不能随便设 ？

      设为 \* 时不能携带 Cookie，且有安全风险。

      2. 预检请求什么时候触发？

      非 GET/POST/HEAD 或自定义请求头时会触发 OPTIONS 预检。

      3. 反向代理跨域的原理是什么？

      通过同源的代理服务器中转请求，浏览器认为访问的还是同源域名。

4.  **Vue 相关**

    - **_Vue 生命周期_**

      1. Vue2 生命周期顺序

      `beforeCreate`

      组件实例刚创建，data 和 methods 还没初始化。

      常用：几乎不用，因数据和事件都没可用。

      `created`

      完成数据观测（响应式）和事件绑定，但还没挂载 DOM。

      常用：初始数据获取（如 API 请求）。

      `beforeMount`

      模板编译完成，准备挂载。

      `mounted`

      DOM 已挂载，可操作真实 DOM。

      `beforeUpdate`

      数据变化，更新 DOM 前调用。

      `updated`

      视图更新完成。

      `beforeDestroy`

      实例销毁前，适合清理定时器、解绑事件。

      `destroyed`

      实例已销毁，数据绑定、事件监听都移除。

      2. Vue3 生命周期（Composition API 版）

      Vue3 移除了 beforeDestroy / destroyed，改为 beforeUnmount / unmounted。

      常用钩子函数：

      ```js
      import {
        onBeforeMount,
        onMounted,
        onBeforeUpdate,
        onUpdated,
        onBeforeUnmount,
        onUnmounted
      } from 'vue'
      ```

      对应关系（Vue2 → Vue3）：
      | Vue2 | Vue3 |
      |--------------------|----------------------|
      | beforeCreate | setup() |
      | created | setup() |
      | beforeMount | onBeforeMount |
      | mounted | onMounted |
      | beforeUpdate | onBeforeUpdate |
      | updated | onUpdated |
      | beforeDestroy | onBeforeUnmount |
      | destroyed | onUnmounted |

      3. keep-alive 的生命周期

      在 Vue2/Vue3 中，被 keep-alive 缓存的组件会多两个钩子：

      `activated`：从缓存激活

      `deactivated`：切换到缓存状态

      常用场景：

      `activated`：重新获取最新数据

      `deactivated`：保存滚动位置、暂停定时器

      4. 总结
         Vue 生命周期是从创建、挂载、更新到卸载的过程。
         Vue2 有 8 个主要钩子，Vue3 取消 beforeDestroy/destroyed，改为 beforeUnmount/unmounted，并用 Composition API 的 onXXX 系列替代。
         keep-alive 缓存的组件会多出 activated / deactivated 钩子，适合在切换页面时保持状态。

    * _延伸问题_

      1. created 和 mounted 的区别？

      created 数据已可用，但 DOM 未挂载；mounted 可操作真实 DOM。

      2. 为什么建议在 created 请求数据？

      因为可以在挂载前完成数据准备，避免白屏；但有 DOM 依赖时应放在 mounted。

      3. Composition API 下 setup 在哪个生命周期执行？

      在 beforeCreate 之前执行，并且只执行一次。

    - **_Vue 父子组件通信方式_**

      1. 单向数据流（父 → 子）

      props

      父组件通过 props 向子组件传值（响应式）。

      支持类型校验、默认值、必填字段：

      ```js
      props: {
      title: { type: String, required: true, default: '' }
      }
      ```

      2. 子 → 父

      ` $emit（Vue2）` / `defineEmits（Vue3）`

      ```js

      // 子组件
      const emit = defineEmits(['update']);
      emit('update', newValue);
      // 父组件
      <Child @update="handleUpdate" />
      ```

      3. 父调用子方法

      ref 引用子组件实例

      ```js
      // 父组件
      const childRef = ref()
      childRef.value.childMethod()
      ```

      4. 跨层级通信

      provide / inject（Vue3 推荐）

      父组件提供数据，任意后代组件注入使用：

      ```js
      // 父组件
      provide('mapInstance', map)
      // 孙组件
      const mapInstance = inject('mapInstance')
      ```

      Vue2 中也有，但 Vue3 下配合 Composition API 更灵活。

      5. 全局状态管理

      `Vuex`（Vue2 常用） / `Pinia`（Vue3 推荐）

      用于全局共享状态，如用户信息、主题色、地图状态等。

      Pinia API 更简洁，支持 TypeScript 类型推导。

      6. 特殊场景

      事件总线（EventBus）（Vue2 常见，Vue3 需自己实现）

      适合中小型项目组件间通信，但不适合大型项目长期维护。

      URL / 路由参数

      this.$route.params 或 query，刷新后仍可保留。

    * _延伸问题_

      1. provide/inject 是响应式的吗？

      默认不是，需要配合 ref 或 reactive 才能响应式更新。

      2. Pinia 和 Vuex 的区别？

      Pinia API 更简洁、无 mutation、TypeScript 友好，Vue3 官方推荐。

      3. 什么时候选事件总线？

      小范围快速通信，避免全局状态管理的复杂度，但不适合维护周期长的项目。

    - **_Vue 响应式原理_**

      1. Vue2：`Object.defineProperty`

      核心思路：

      在数据初始化阶段，通过 Object.defineProperty 劫持对象的每个属性的 getter 和 setter。

            getter：依赖收集（记录哪些视图/计算属性依赖当前数据）。

            setter：数据变更时触发依赖更新（发布-订阅模式）。

      代码示例（简化版）：

      ```js
      function defineReactive(obj, key, val) {
        Object.defineProperty(obj, key, {
          get() {
            // 依赖收集
            return val
          },
          set(newVal) {
            if (newVal !== val) {
              val = newVal
              // 派发更新
            }
          }
        })
      }
      ```

      缺点：

      无法监听新增/删除属性（需用 Vue.set / Vue.delete）。

      无法监听数组下标变化和 length 变化（需用数组变异方法覆盖）。

      2. Vue3：`Proxy + Reflect`

      核心思路：

      用 Proxy 一次性拦截整个对象的操作（读、写、删、判断等）。

      Reflect 用于标准化对象操作，让 getter/setter 内部逻辑更简洁。

      代码示例（简化版）：

      ```js
      const handler = {
        get(target, key, receiver) {
          // 依赖收集
          return Reflect.get(target, key, receiver)
        },
        set(target, key, value, receiver) {
          // 派发更新
          return Reflect.set(target, key, value, receiver)
        }
      }
      const state = new Proxy(obj, handler)
      ```

      优点：

      可监听新增/删除属性。

      可监听数组下标和 length 变化。

      拦截范围更广（has、deleteProperty、ownKeys 等）。

      3. Vue 响应式的依赖收集机制

      每个响应式对象属性对应一个 Dep（依赖管理器）。

      组件渲染时，访问属性 → getter 收集依赖（当前 watcher）。

      数据变化时 → setter 通知 Dep → 触发 watcher 更新 → 视图重新渲染。

      4. 总结
         Vue2 用 Object.defineProperty 劫持属性 getter/setter 实现响应式，优点是兼容性好，缺点是无法监听新增属性和数组下标变化。
         Vue3 用 Proxy + Reflect 一次性拦截对象读写，能监听新增/删除属性、数组 length 变化，拦截范围更广，代码更简洁。
         核心依赖收集机制基于发布-订阅模式，属性变更触发对应 watcher 更新视图。

    * _延伸问题_

      1. Proxy 为什么不能 polyfill？

      Proxy 是 ES6 新特性，无法用 ES5 模拟，必须依赖浏览器原生支持。

      2. Vue3 的 Proxy 为什么性能更好？

      一次性拦截整个对象，无需递归遍历所有属性初始化劫持。

      3. 依赖收集是怎么避免重复的？

      Vue 内部使用 Set 存储依赖，天然去重。

    - **_Vue 虚拟 DOM 与 diff 算法_**

      1. 为什么需要虚拟 DOM

      直接操作真实 DOM 的缺点：

            DOM 操作开销大（浏览器要重新布局、绘制）。

            手动更新容易出错，难以维护大规模应用。

      虚拟 DOM（VNode）：

            用 JS 对象描述真实 DOM 结构（标签、属性、子节点等）。

            通过 diff 算法比较新旧虚拟 DOM，计算最小变更，再一次性更新真实 DOM。

      2. Vue diff 算法的核心思路

      Vue 的 diff 算法是同层比较、双端指针优化的版本，不会跨层比较节点。

      基本流程：

            新旧虚拟 DOM 树对比，从根节点开始。

            如果节点类型不同 → 直接替换。

            如果相同 → 只比较属性和子节点。

            双端 diff（Vue2/Vue3）：

            维护新旧两组子节点的头尾指针（oldStart, oldEnd, newStart, newEnd）。

      比较 4 种情况：

            旧头 vs 新头 → 匹配 → 都向后移。

            旧尾 vs 新尾 → 匹配 → 都向前移。

            旧头 vs 新尾 → 旧头移动到末尾。

            旧尾 vs 新头 → 旧尾移动到开头。

      其余情况：用 key 查找可复用节点，找不到就新建节点。

      3. Vue3 的优化

      `静态提升（Static Hoisting）`：

      不变的节点在编译时抽离，只创建一次，减少 diff 开销。

      `Patch Flag`：

      编译时给动态节点打标记（例如 TEXT、CLASS、STYLE），只比较有标记的部分。

      `Block Tree`：

      分块记录动态节点，减少无关节点的遍历。

      4. 总结
         虚拟 DOM 是用 JS 对象描述真实 DOM，配合 diff 算法计算最小变更再更新 DOM，减少直接操作的开销。
         Vue diff 基于同层比较和双端指针优化，能高效处理节点增删改。
         Vue3 编译时引入静态提升、Patch Flag 和 Block Tree，进一步减少运行时的 diff 成本。

    * _延伸问题_

      1. 为什么 diff 不做跨层比较？

      跨层代价太大，实际场景很少发生，直接替换更快。

      2. key 在 diff 中的作用？

      key 用于唯一标识节点，帮助 diff 精准复用旧节点；缺少 key 会导致复用出错。

      3. React diff 和 Vue diff 有区别吗？

      思路类似，但 Vue2 采用双端指针优化，React 主要是单向从左到右比较。

    - **_Vue 组件性能优化_**
        1. 减少不必要的渲染

        v-if / v-show 合理选择

            频繁切换：v-show（仅切换 display，不销毁 DOM）

            条件渲染少：v-if（按需创建/销毁，初始开销小）

        key 的正确使用

            保证节点复用正确，减少无意义的 DOM 更新。

            避免用 index 作为 key（除非列表永不变动）。

        2. 降低 diff 成本

            keep-alive（缓存组件）

            常用于 tab 切换场景，避免重复渲染。

            配合 activated / deactivated 钩子管理状态。

            v-once（一次性渲染静态节点）

            适合内容永不变化的节点（如静态展示区）。

        3. 减少计算开销

        computed 缓存

            computed 会基于依赖缓存结果，比 methods 每次调用都执行更高效。

        watch 精准监听

            避免全对象深度监听，改为监听具体属性。

            可用 watchEffect（Vue3）实现按需依赖收集。

        4. 按需加载与懒加载

        异步组件

            defineAsyncComponent（Vue3）：按需加载组件，减少首屏包体积。

        路由懒加载
        ```js
            const Foo = () => import('@/components/Foo.vue');
        ```

        图片懒加载、资源分片加载。

        5. 编译与构建优化

            Tree Shaking（移除无用代码）

            CDN 加载第三方库（减少打包体积）

            生产环境移除 console.log / debugger（terser 插件配置）

        总结
        Vue 组件性能优化可以从四方面入手：
            第一，减少不必要的渲染，比如合理选择 v-if / v-show，正确使用 key；
            第二，降低 diff 成本，用 keep-alive 缓存组件，v-once 渲染静态节点；
            第三，减少计算开销，用 computed 缓存结果，watch 精准监听；
            第四，按需加载，用异步组件、路由懒加载和资源懒加载减少首屏包体积。
    * _延伸问题_
        1. keep-alive 和 v-if 一起用会发生什么？

        v-if 销毁会清除缓存，等于没用 keep-alive。

        2. computed 和 watch 的区别？

        computed 适合基于依赖的派生数据，且有缓存；watch 适合数据变化触发副作用。

        3. Vue3 静态提升是什么？

        编译时将静态节点抽离，减少运行时创建和 diff。

---

### **模块 2：项目延伸问题**

> **目标**：让你能从简历出发，答到深度

 **_为什么前端选 Vue3 而不是 React / Vue2？_**
    vue3是composition API 可复用逻辑，typescript友好，proxy响应式性能提升，tree-shaking优化，结合项目的特点是组件模块化高、逻辑抽离多，vue3更契合，VUE2无法满足类型推导和性能需求
    vue3在类型安全、逻辑复用和运行性能上具有优势，能契合我们模块化、高交互的项目。

 **_为什么状态管理选 Pinia 而不是 Vuex_**
 
1. **地理空间数据与模型科研工作平台**

   - 如何衡量“组件复用率”？
   - 为什么复用率不是 100%，如何进一步提升？
   - 分片上传的分片大小如何选择？断点续传如何实现？
   - WebSocket 如何保证消息有序与断线重连？
   - 大语言模型集成的安全性与性能优化怎么做？

2. **多轨道演播系统**

   - 轨道渲染卡顿的原因与优化方法？
   - 多媒体素材时间轴同步的实现思路？
   - 自动字幕生成的核心技术路线？

3. **长江洲滩崩岸预警系统**

   - 实时监测数据的可视化渲染如何避免卡顿？
   - 模型参数配置如何自动化？
   - 如何减少对专家经验的依赖，提高预测准确率？

---

### **模块 3：GIS / Mapbox 专项**

> **目标**：利用你独特的地图开发经验加分

1. Mapbox 数据源类型（GeoJSON、Vector、Raster）的区别与应用场景
2. 高性能渲染大数据点的优化方案（cluster、geojson-vt、Web Worker）
3. 坐标系转换（WGS84 ↔ Web Mercator）
4. 如何在 Mapbox 上实现热力图，并优化性能
5. 如何处理实时地图数据更新的闪烁与延迟问题

---

### **模块 4：工程化与性能优化**

> **目标**：应对中高年资面试官的工程思维追问

1. Vite 和 Webpack 的差异与打包优化策略
2. 前端 CI/CD 流程如何搭建？
3. 浏览器缓存策略（强缓存 vs 协商缓存）
4. 懒加载与预加载的区别与实现
5. 如何监控并优化首屏性能（FP、FCP、LCP、TTI）？

---

### **模块 5：算法与代码实现**

> **目标**：应对白板/在线编程环节

1. 数组类

   - 两数之和（Two Sum）
   - 滑动窗口求最大子数组和
   - 数组去重（Set / 双指针）

2. 字符串类

   - 反转单词顺序（LC151）
   - 最长不重复子串（LC3）
   - 字符串压缩（aabcc → a2b1c2）

3. 数据结构类

   - LRU 缓存实现
   - 用两个栈实现队列
   - 二叉树的层序遍历

4. 模拟类

   - 大整数加法
   - 括号匹配检测
   - 合并区间

---

### **模块 6：思维题 / 产品八股文**

> **目标**：应对业务面试官的估算题、开放题

1. 估算北京一天的外卖订单量
2. 设计一个前端文件上传系统，支持断点续传和秒传
3. 如何设计一个前端埋点方案，统计页面停留时长和用户行为
4. 如果要支持地图上 10 万个点的实时渲染，你会怎么设计？
